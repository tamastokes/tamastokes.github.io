---
layout: post
title:  "Learning about good solos from crap solos"
date:   2023-01-30 15:04:00 +0100
categories:
---
A few years ago I was sitting in a jazz cafe, when a group of young saxophone players started a jam session.  The players were young and seemingly at the beginning of their studies, so most of their solos were obviously not very good.  As if there's basically any kind of music around, I usually can't help focussing on it, I stopped reading and took my full attention to them.  After a while, I recognized something interesting: while in most cases it's quite difficult to explain why a good solo is good, it's almost always very obvious why a crap solo is crap.  Moreover, as crap solos often lack (or sometimes, conversely, over-exaggerate) some important attributes of good solos, you can actually learn a lot about good solos if you listen to some crap solos.  So if you want to understand why a John Coltrane solo is good, you shouldn't only listen to him or Charlie Parker, but also some folks who play really poorly.

Yeah, that's nice but this is (mostly) a tech blog.  How does this apply to tech?  In fact, what reminded me of this story is the book "SQL Antipatterns" by Bill Karwin.  I think this is a fantastic book, and a significant part of why I love it is because of its approach, where not only does he present best practices (good solos), but he explains the reasons behind his recommended choices through the lense of anti-patterns (crap solos).  And similarly to jazz, it's much easier to explain (from the writer's point of you) and hence understand (from the reader's point of you) the consequences of bad choices than the non-consequences of good choices.

The other reason I liked this book is that the best practices it recommends (and this is the point where the analogy with jazz no longer works) are never creative or maybe surprising positive patterns, but to be honest quite boring, common sense solutions.  This really made me think, but it actually makes a lot of sense: if the solution for any technical problem is not intuitive, then it must be a design problem somewhere else.  Moreover, in many cases this unintuitive nature of the creative solutions is what actually make people gravitate to anti-patterns.  The opposite of a crap solo is a good solo, whereas it looks like the opposite of an anti-pattern should be a boring solo.

OK, but what about the well-known design patterns (Factory, Visitor, etc.)?  I now tend to see them as workarounds.  Workarounds for some limitations of the progamming paradigm (OOP) and the programming langauge (e.g. C++) for which these patterns were created for.  (However, before you throw your Gang of Four book to the waste-basket, recall that currently these are the programming languages and paradigms we use, therefore we regularly face these problems.  And as still these design patterns are considered the best practices for such problems, it's still worth learning them.)

Though an arguably even more rewarding reason for studying these design patterns is that they can help understand those limitations, gaps, consequences (kind of anti-patterns???) of some programming language design choices.  Moreover, as the fact that there are multiple competing programming languages and paradigms reminds us [that it's all about the trade-offs](https://tamastokes.github.io/2023/01/10/productive-debates-discover-tradeoffs.html), comparing the typical, say, OOP patterns with those of, say, functional programming, can really help understand the trade-offs between these worlds.  Consider, for example, that the Singleton, originally listed as a design pattern in the GoF book, is now mostly seen as an anti-pattern because it makes unit testing difficult.  I think this tells a lot about how drastically priorities changed in 20 years, and some of the trade-offs the wide adoption of unit testing has brought with itself.
